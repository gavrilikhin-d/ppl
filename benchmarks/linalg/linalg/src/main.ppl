type Matrix:
	rows: Integer
	columns: Integer
	data: Array<Rational>

type MutRowSlice:
	row: Integer
	matrix: &mut Matrix

fn RowSlice from <slice: MutRowSlice> -> RowSlice:
	return RowSlice { row: slice.row, matrix: slice.matrix }

fn String from <slice: MutRowSlice> -> String:
	return String from (RowSlice from slice)

// FIXME: may be out of bounds
fn <slice: &MutRowSlice> [ <column: &Integer> ] -> &mut Rational:
	let i = slice.matrix.columns * slice.row + column
	return slice.matrix.data[i]


type RowSlice:
	row: Integer
	matrix: &Matrix

// FIXME: may be out of bounds
fn <slice: &RowSlice> [ <column: &Integer> ] -> &Rational:
	let i = slice.matrix.columns * slice.row + column
	return slice.matrix.data[i]

fn String from <slice: RowSlice> -> String:
	let mut str = "["
	let n = slice.matrix.columns
	let mut i = n * slice.row
	let end = i + n
	let data = slice.matrix.data
	if i < data.size:
		str += (String from data[i])
		i += 1
		while (i < data.size) and (i < end):
			str += ", "
			str += (String from data[i])
			i += 1
	str += "]"
	return str

fn <rows: Integer> x <columns: Integer> Matrix -> Matrix:
	let size = rows * columns
	let mut data = Rational[]
	let mut i = 0
	while i < size:
		push 0.0 to data 
		i += 1

	return Matrix { rows, columns, data }

fn <matrix: &mut Matrix> [ <row: Integer> ] -> MutRowSlice:
	return MutRowSlice { matrix, row }

fn <matrix: &Matrix> [ <row: Integer> ] -> RowSlice:
	return RowSlice { matrix, row }

fn String from <m: Matrix> -> String:
	let mut str = "["
	let mut i = 0
	if i < m.rows:
		str += (String from m[i])
		i += 1
		while i < m.rows:
			str += "\n "
			str += (String from m[i])
			i += 1
	str += "]"
	return str

fn Matrix with <diagonal: Array<Rational>> on diagonal -> Matrix:
	let n = diagonal.size
	let mut m = n x n Matrix
	let mut i = 0
	while i < n:
		(m[i])[i] = diagonal[i]
		i += 1
	return m

fn rank <n: Integer> identity Matrix -> Matrix:
	return Matrix with (repeat 1.0 n times) on diagonal

fn <a: &Rational> * <m: &Matrix> -> Matrix:
	let mut n = m.rows x m.columns Matrix
	let mut i = 0
	while i < n.data.size:
		n.data[i] = a * m.data[i]
		i += 1
	return n

fn <a: &Matrix> + <b: &Matrix> -> Matrix:
	assert (a.rows == b.rows and a.columns == b.columns) "Can't add matrices of different dimensions"
	let mut m = a.rows x a.columns Matrix
	let mut i = 0
	while i < m.data.size:
		(m[0])[0] += a.data[i] + b.data[i]
		i += 1
	return m

fn <a: Matrix> * <b: Matrix> -> Matrix:
	assert a.columns == b.rows "Can't multiply matrices of incompatible dimensions"
	let mut n = a.rows x b.columns Matrix
	let mut i = 0
	while i < a.rows:
		let mut j = 0
		while j < b.columns:
			let mut k = 0
			while k < a.columns:
				(n[i])[j] += (a[i])[k] * (b[k])[j]
				k += 1
			j += 1
		i += 1
	return n

fn transposed <m: Matrix> -> Matrix:
	let columns = m.columns
	let rows = m.rows
	let mut n = columns x rows Matrix
	let mut i = 0
	while i < rows:
		let mut j = 0
		while j < columns:
			(n[j])[i] = (m[i])[j]
			j += 1
		i += 1
	return n

fn Matrix from <data: Array<Rational>> -> Matrix:
	let mut rows = 1
	if data is empty:
		rows = 0
	return Matrix { rows, columns: data.size, data }

fn Vector from <data: Array<Rational>> -> Matrix:
	let row = Matrix from data
	return transposed row

fn <rows: Integer> x <columns: Integer> Hilbert Matrix -> Matrix:
	let mut m = rows x columns Matrix
	let mut i = 0
	while i < rows:
		let mut j = 0
		while j < columns:
			(m[i])[j] = 1 / (i + j + 1)
			j += 1
		i += 1
	return m

// let e = rank 3 identity Matrix
// println e

// println 2.0 * e
let ones = repeat 1.0 3 times
println (5 x 5 Hilbert Matrix)

// fn run code:
// 	let mut a = rank 3 identity Matrix
// 	(a[0])[1] = 1.0
// 	println a
// 	let b = transposed a
// 	println b
// 	println a * b

// run code