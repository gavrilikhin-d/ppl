type Matrix:
	rows: Integer
	columns: Integer
	data: Array<Rational>

type MutRowSlice:
	row: Integer
	matrix: &mut Matrix

fn RowSlice from <slice: MutRowSlice> -> RowSlice:
	return RowSlice { row: slice.row, matrix: slice.matrix }

fn String from <slice: MutRowSlice> -> String:
	return String from (RowSlice from slice)

// FIXME: may be out of bounds
fn <slice: &MutRowSlice> [ <column: &Integer> ] -> &mut Rational:
	let i = slice.matrix.columns * slice.row + column
	return slice.matrix.data[i]


type RowSlice:
	row: Integer
	matrix: &Matrix

// FIXME: may be out of bounds
fn <slice: &RowSlice> [ <column: &Integer> ] -> &Rational:
	let i = slice.matrix.columns * slice.row + column
	return slice.matrix.data[i]

fn String from <slice: RowSlice> -> String:
	let mut str = "["
	let n = slice.matrix.columns
	let mut i = n * slice.row
	let end = i + n
	let data = slice.matrix.data
	if i < data.size:
		str += (String from data[i])
		i += 1
		while (i < data.size) and (i < end):
			str += ", "
			str += (String from data[i])
			i += 1
	str += "]"
	return str

fn <rows: Integer> x <columns: Integer> Matrix -> Matrix:
	let size = rows * columns
	let mut data = Rational[]
	let mut i = 0
	while i < size:
		push 0.0 to data 
		i += 1

	return Matrix { rows, columns, data }

fn <matrix: &mut Matrix> [ <row: Integer> ] -> MutRowSlice:
	return MutRowSlice { matrix, row }

fn <matrix: &Matrix> [ <row: Integer> ] -> RowSlice:
	return RowSlice { matrix, row }

fn String from <m: Matrix> -> String:
	let mut str = "["
	let mut i = 0
	if i < m.rows:
		str += (String from m[i])
		i += 1
		while i < m.rows:
			str += "\n "
			str += (String from m[i])
			i += 1
	str += "]"
	return str


let mut a = 3 x 3 Matrix
(a[0])[0] = 1.0
println a
println (a[1])