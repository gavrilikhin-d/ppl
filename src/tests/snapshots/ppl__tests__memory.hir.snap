---
source: src/tests/mod.rs
expression: hir
---
let address: MemoryAddress = allocate 1 (Type<Integer>:Type<Integer>)
let x: ReferenceMut<Integer> = (Type<Integer>:Type<Integer>) at (address:MemoryAddress)
(x:ReferenceMut<Integer>) = 0
println clone (*x:Integer)
(x:ReferenceMut<Integer>) = 1
println clone (*x:Integer)

==MONOMORPHIZED==


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = clone (ty:Type<Integer>).size
	return ($tmp@4399:Integer)


fn<Integer> allocate <n: Integer> <$arg1: Type<Integer>> -> MemoryAddress:
	let $tmp@760: MemoryAddress = allocate clone (n:Integer) * size of (Type<Integer>:Type<Integer>) bytes
	destroy (n:Integer)
	return ($tmp@760:MemoryAddress)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: MemoryAddress> -> ReferenceMut<Integer>

@mangle_as("integer_as_string")
fn String from <:Integer> -> String

fn<Integer> println <x: Integer> -> None:
	let $tmp@314: None = println String from (x:Integer)
	return ($tmp@314:None)


@mangle_as("integer_as_string")
fn String from <:Integer> -> String

fn<Integer> println <x: Integer> -> None:
	let $tmp@314: None = println String from (x:Integer)
	return ($tmp@314:None)
