---
source: src/tests/mod.rs
expression: hir
---
let address: MemoryAddress = `allocate <:Integer> <:Type<Integer>>`(1, Type<Integer> { name: "Integer", size: 8 })
let x: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`(Type<Integer> { name: "Integer", size: 8 }, (&address:Reference<MemoryAddress>))
(x:ReferenceMut<Integer>) = 0
`println <:Integer>`(`clone <:Reference<Integer>>`((*x:Integer)))
(x:ReferenceMut<Integer>) = 1
`println <:Integer>`(`clone <:Reference<Integer>>`((*x:Integer)))

==MONOMORPHIZED==


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4426: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4426:Integer)


fn<Integer> allocate <n: Integer> <$arg1: Type<Integer>> -> MemoryAddress:
	let $tmp@760: MemoryAddress = `allocate <:Integer> bytes`(`<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((n:Integer)), `size of <:Type<Integer>>`(Type<Integer> { name: "Integer", size: 8 })))
	`destroy <:ReferenceMut<Integer>>`((n:Integer))
	return ($tmp@760:MemoryAddress)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)



@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)
