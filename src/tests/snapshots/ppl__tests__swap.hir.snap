---
source: src/tests/mod.rs
expression: hir
---
let mut a: Integer = 1
let mut b: Integer = 2
`print <:Integer>`(`clone <:Reference<Integer>>`((a:Integer)))
`print <:String>`(" ")
`println <:Integer>`(`clone <:Reference<Integer>>`((b:Integer)))
`swap <:ReferenceMut<Integer>> and <:ReferenceMut<Integer>>`((&a:ReferenceMut<Integer>), (&b:ReferenceMut<Integer>))
`print <:Integer>`(`clone <:Reference<Integer>>`((a:Integer)))
`print <:String>`(" ")
`println <:Integer>`(`clone <:Reference<Integer>>`((b:Integer)))
`destroy <:ReferenceMut<Integer>>`((a:Integer))
`destroy <:ReferenceMut<Integer>>`((b:Integer))

==MONOMORPHIZED==


@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn print <x: Integer> -> None:
	let $tmp@128: None = `print <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@128:None)



@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)



fn<Integer> swap <a: ReferenceMut<Integer>> and <b: ReferenceMut<Integer>> -> None:
	let tmp: Integer = (*a:Integer)
	(a:ReferenceMut<Integer>) = (*b:Integer)
	(b:ReferenceMut<Integer>) = (tmp:Integer)


@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn print <x: Integer> -> None:
	let $tmp@128: None = `print <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@128:None)



@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)
