---
source: src/tests/mod.rs
expression: hir
---
let mut x: Integer = 1
let y: ReferenceMut<Integer> = `reference to mutable <:ReferenceMut<Integer>>`((&x:ReferenceMut<Integer>))
`println <:Integer>`((*y:Integer))
(y:ReferenceMut<Integer>) = 2
`println <:Integer>`((*y:Integer))
`println <:Integer>`((x:Integer))

==MONOMORPHIZED==


fn<Integer> reference to mutable <ref: ReferenceMut<Integer>> -> ReferenceMut<Integer>:
	let mut $tmp@4628: ReferenceMut<Integer> = (ref:ReferenceMut<Integer>)
	return ($tmp@4628:ReferenceMut<Integer>)


@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)



@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)



@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)
