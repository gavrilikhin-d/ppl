---
source: src/tests/mod.rs
expression: hir
---
`println <:Rational>`(0.0)
`println <:Rational>`(`+ <:Rational>`(1.0))
`println <:Rational>`(`- <:Rational>`(2.0))
`println <:Rational>`(`<:Rational> + <:Rational>`(1.0, 2.0))
`println <:Rational>`(`<:Rational> - <:Rational>`(5.0, 1.0))
`println <:Rational>`(`<:Rational> * <:Rational>`(2.5, 2.0))
`println <:Rational>`(`<:Rational> / <:Rational>`(9.0, `<:Integer> / <:Integer>`(3, 2)))
`println <:Bool>`(`<:Rational> == <:Rational>`(0.0, 0.0))
`println <:Bool>`(`<:Rational> != <:Rational>`(1.0, 0.0))
`println <:Bool>`(`<:Rational> < <:Rational>`(0.0, 1.0))
`println <:Bool>`(`<:Rational> > <:Rational>`(1.0, 0.0))
`println <:Bool>`(`<:Rational> <= <:Rational>`(0.0, 0.0))
`println <:Bool>`(`<:Rational> <= <:Rational>`(0.0, 1.0))
`println <:Bool>`(`<:Rational> >= <:Rational>`(0.0, 0.0))
`println <:Bool>`(`<:Rational> >= <:Rational>`(1.0, 0.0))

==MONOMORPHIZED==


@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



@mangle_as("rational_as_string")
fn String from <$arg0: Rational> -> String

fn println <x: Rational> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Rational>`((x:Rational)))
	return ($tmp@176:None)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_eq_rational")
fn <$arg0: Rational> == <$arg1: Rational> -> Bool

fn <x: Rational> != <y: Rational> -> Bool:
	let $tmp@776: Bool = `not <:Bool>`(`<:Rational> == <:Rational>`((x:Rational), (y:Rational)))
	return ($tmp@776:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_less_rational")
fn <$arg0: Rational> < <$arg1: Rational> -> Bool

fn <x: Rational> > <y: Rational> -> Bool:
	let $tmp@1032: Bool = `<:Rational> < <:Rational>`((y:Rational), (x:Rational))
	return ($tmp@1032:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_less_rational")
fn <$arg0: Rational> < <$arg1: Rational> -> Bool

fn <x: Rational> > <y: Rational> -> Bool:
	let $tmp@1032: Bool = `<:Rational> < <:Rational>`((y:Rational), (x:Rational))
	return ($tmp@1032:Bool)



fn <x: Rational> <= <y: Rational> -> Bool:
	let $tmp@1068: Bool = `not <:Bool>`(`<:Rational> > <:Rational>`((x:Rational), (y:Rational)))
	return ($tmp@1068:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_less_rational")
fn <$arg0: Rational> < <$arg1: Rational> -> Bool

fn <x: Rational> > <y: Rational> -> Bool:
	let $tmp@1032: Bool = `<:Rational> < <:Rational>`((y:Rational), (x:Rational))
	return ($tmp@1032:Bool)



fn <x: Rational> <= <y: Rational> -> Bool:
	let $tmp@1068: Bool = `not <:Bool>`(`<:Rational> > <:Rational>`((x:Rational), (y:Rational)))
	return ($tmp@1068:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_less_rational")
fn <$arg0: Rational> < <$arg1: Rational> -> Bool

fn <x: Rational> >= <y: Rational> -> Bool:
	let $tmp@1110: Bool = `not <:Bool>`(`<:Rational> < <:Rational>`((x:Rational), (y:Rational)))
	return ($tmp@1110:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



@mangle_as("rational_less_rational")
fn <$arg0: Rational> < <$arg1: Rational> -> Bool

fn <x: Rational> >= <y: Rational> -> Bool:
	let $tmp@1110: Bool = `not <:Bool>`(`<:Rational> < <:Rational>`((x:Rational), (y:Rational)))
	return ($tmp@1110:Bool)



fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)
