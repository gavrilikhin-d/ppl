---
source: src/tests/mod.rs
expression: hir
---
let mut arr: Array<Integer> = `<:Type<Integer>> [ ]`((Type<Integer>:Type<Integer>))
let mut i: Integer = 2
`println <:Array<Integer>>`((arr:Array<Integer>))
if `<:Reference<Array<Integer>>> is empty`((&arr:ReferenceMut<Array<Integer>>)):
	`println <:String>`("Empty")

`push <:Integer> to <:ReferenceMut<Array<Integer>>>`(1, (&arr:ReferenceMut<Array<Integer>>))
`println <:Array<Integer>>`((arr:Array<Integer>))
if `<:Reference<Array<Integer>>> is not empty`((&arr:ReferenceMut<Array<Integer>>)):
	`println <:String>`("Not empty")

`println <:Integer>`(`clone <:Reference<Integer>>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&arr:ReferenceMut<Array<Integer>>), 0):Integer)))
while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), 10):
	`push <:Integer> to <:ReferenceMut<Array<Integer>>>`(`clone <:Reference<Integer>>`((i:Integer)), (&arr:ReferenceMut<Array<Integer>>))
	`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)
	`println <:Array<Integer>>`((arr:Array<Integer>))

`destroy <:ReferenceMut<Integer>>`((i:Integer))

==MONOMORPHIZED==


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> allocate <n: Integer> <$arg1: Type<Integer>> -> MemoryAddress:
	let $tmp@760: MemoryAddress = `allocate <:Integer> bytes`(`<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((n:Integer)), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	`destroy <:ReferenceMut<Integer>>`((n:Integer))
	return ($tmp@760:MemoryAddress)


fn<Integer> <$arg0: Type<Integer>> [ ] -> Array<Integer>:
	let capacity: Integer = 8
	let data: MemoryAddress = `allocate <:Integer> <:Type<Integer>>`(`clone <:Reference<Integer>>`((capacity:Integer)), (Type<Integer>:Type<Integer>))
	let $tmp@260: Array<Integer> = Array<Integer> { size: 0, capacity: `clone <:Reference<Integer>>`((capacity:Integer)), data: (data:MemoryAddress) }
	`destroy <:ReferenceMut<Integer>>`((capacity:Integer))
	return ($tmp@260:Array<Integer>)


fn<Integer> String from <array: Array<Integer>> -> String:
	let mut str: String = "["
	if `<:Reference<Array<Integer>>> is not empty`((&array:Reference<Array<Integer>>)):
		`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), 0):Integer)))
		let mut i: Integer = 1
		while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((array:Array<Integer>).size)):
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), ", ")
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), `clone <:Reference<Integer>>`((i:Integer))):Integer)))
			`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)

		`destroy <:ReferenceMut<Integer>>`((i:Integer))

	`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), "]")
	let $tmp@1497: String = `clone <:Reference<String>>`((str:String))
	`destroy <:ReferenceMut<String>>`((str:String))
	return ($tmp@1497:String)


fn println <x: Array<Integer>> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Array<Integer>>`((x:Array<Integer>)))
	return ($tmp@176:None)



fn<Integer> <array: Reference<Array<Integer>>> is empty -> Bool:
	let $tmp@1173: Bool = `<:Integer> == <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), 0)
	return ($tmp@1173:Bool)


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> allocate <n: Integer> <$arg1: Type<Integer>> -> MemoryAddress:
	let $tmp@760: MemoryAddress = `allocate <:Integer> bytes`(`<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((n:Integer)), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	`destroy <:ReferenceMut<Integer>>`((n:Integer))
	return ($tmp@760:MemoryAddress)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

fn<Integer> <array: Reference<Array<Integer>>> [ <i: Integer> ] -> Reference<Integer>:
	let address: MemoryAddress = `<:MemoryAddress> + <:Integer>`((*array:Array<Integer>).data, `<:Integer> * <:Integer>`((i:Integer), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	return `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&address:Reference<MemoryAddress>))


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> copy <:Type<Integer>> from <src: Reference<MemoryAddress>> to <dst: Reference<MemoryAddress>> -> None:
	`copy <:Reference<Integer>> bytes from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((&`size of <:Type<Integer>>`((Type<Integer>:Type<Integer>)):Reference<Integer>), (src:Reference<MemoryAddress>), (dst:Reference<MemoryAddress>))


fn<Integer> copy <src: Reference<Integer>> to <dst: ReferenceMut<Integer>> -> None:
	let $tmp@1518: MemoryAddress = `address of <:Reference<Integer>>`((src:Reference<Integer>))
	let $tmp@1538: MemoryAddress = `address of <:Reference<Integer>>`((dst:ReferenceMut<Integer>))
	`copy <:Type<Integer>> from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1518:Reference<MemoryAddress>), (&$tmp@1538:Reference<MemoryAddress>))


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> copy <:Type<Integer>> from <src: Reference<MemoryAddress>> to <dst: Reference<MemoryAddress>> -> None:
	`copy <:Reference<Integer>> bytes from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((&`size of <:Type<Integer>>`((Type<Integer>:Type<Integer>)):Reference<Integer>), (src:Reference<MemoryAddress>), (dst:Reference<MemoryAddress>))


fn<Integer> copy <src: Reference<Integer>> to <dst: ReferenceMut<Integer>> -> None:
	let $tmp@1518: MemoryAddress = `address of <:Reference<Integer>>`((src:Reference<Integer>))
	let $tmp@1538: MemoryAddress = `address of <:Reference<Integer>>`((dst:ReferenceMut<Integer>))
	`copy <:Type<Integer>> from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1518:Reference<MemoryAddress>), (&$tmp@1538:Reference<MemoryAddress>))


fn<Integer> push <x: Integer> to <array: ReferenceMut<Array<Integer>>> -> None:
	let bytes: Integer = `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))
	if `<:Integer> == <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), `clone <:Reference<Integer>>`((*array:Array<Integer>).capacity)):
		let new_capacity: Integer = `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).capacity), 2)
		let new_data: MemoryAddress = `allocate <:Integer> <:Type<Integer>>`(`clone <:Reference<Integer>>`((new_capacity:Integer)), (Type<Integer>:Type<Integer>))
		let mut i: Integer = 0
		while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((*array:Array<Integer>).size)):
			let $tmp@916: MemoryAddress = `<:MemoryAddress> + <:Integer>`((new_data:MemoryAddress), `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((bytes:Integer))))
			let value: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@916:Reference<MemoryAddress>))
			`copy <:Reference<Integer>> to <:ReferenceMut<Integer>>`(`<:Reference<Array<Integer>>> [ <:Integer> ]`((array:ReferenceMut<Array<Integer>>), `clone <:Reference<Integer>>`((i:Integer))), (value:ReferenceMut<Integer>))
			`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)

		`free <:Reference<MemoryAddress>>`((&(*array:Array<Integer>).data:ReferenceMut<MemoryAddress>))
		(*array:Array<Integer>).data = (new_data:MemoryAddress)
		`destroy <:ReferenceMut<Integer>>`((*array:Array<Integer>).capacity)
		(*array:Array<Integer>).capacity = `clone <:Reference<Integer>>`((new_capacity:Integer))
		`destroy <:ReferenceMut<Integer>>`((new_capacity:Integer))
		`destroy <:ReferenceMut<Integer>>`((i:Integer))

	let $tmp@1068: MemoryAddress = `<:MemoryAddress> + <:Integer>`((*array:Array<Integer>).data, `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), `clone <:Reference<Integer>>`((bytes:Integer))))
	let value: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1068:Reference<MemoryAddress>))
	`copy <:Reference<Integer>> to <:ReferenceMut<Integer>>`((&x:Reference<Integer>), (value:ReferenceMut<Integer>))
	`<:ReferenceMut<Integer>> += <:Integer>`((&(*array:Array<Integer>).size:ReferenceMut<Integer>), 1)
	`destroy <:ReferenceMut<Integer>>`((bytes:Integer))


fn<Integer> String from <array: Array<Integer>> -> String:
	let mut str: String = "["
	if `<:Reference<Array<Integer>>> is not empty`((&array:Reference<Array<Integer>>)):
		`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), 0):Integer)))
		let mut i: Integer = 1
		while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((array:Array<Integer>).size)):
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), ", ")
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), `clone <:Reference<Integer>>`((i:Integer))):Integer)))
			`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)

		`destroy <:ReferenceMut<Integer>>`((i:Integer))

	`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), "]")
	let $tmp@1497: String = `clone <:Reference<String>>`((str:String))
	`destroy <:ReferenceMut<String>>`((str:String))
	return ($tmp@1497:String)


fn println <x: Array<Integer>> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Array<Integer>>`((x:Array<Integer>)))
	return ($tmp@176:None)



fn<Integer> <array: Reference<Array<Integer>>> is not empty -> Bool:
	let $tmp@1230: Bool = `<:Integer> > <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), 0)
	return ($tmp@1230:Bool)


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

fn<Integer> <array: Reference<Array<Integer>>> [ <i: Integer> ] -> Reference<Integer>:
	let address: MemoryAddress = `<:MemoryAddress> + <:Integer>`((*array:Array<Integer>).data, `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	let mut $tmp@467: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&address:Reference<MemoryAddress>))
	`destroy <:ReferenceMut<Integer>>`((i:Integer))
	return ($tmp@467:ReferenceMut<Integer>)


@mangle_as("integer_as_string")
fn String from <$arg0: Integer> -> String

fn println <x: Integer> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Integer>`((x:Integer)))
	return ($tmp@176:None)



fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> allocate <n: Integer> <$arg1: Type<Integer>> -> MemoryAddress:
	let $tmp@760: MemoryAddress = `allocate <:Integer> bytes`(`<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((n:Integer)), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	`destroy <:ReferenceMut<Integer>>`((n:Integer))
	return ($tmp@760:MemoryAddress)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

fn<Integer> <array: Reference<Array<Integer>>> [ <i: Integer> ] -> Reference<Integer>:
	let address: MemoryAddress = `<:MemoryAddress> + <:Integer>`((*array:Array<Integer>).data, `<:Integer> * <:Integer>`((i:Integer), `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))))
	return `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&address:Reference<MemoryAddress>))


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> copy <:Type<Integer>> from <src: Reference<MemoryAddress>> to <dst: Reference<MemoryAddress>> -> None:
	`copy <:Reference<Integer>> bytes from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((&`size of <:Type<Integer>>`((Type<Integer>:Type<Integer>)):Reference<Integer>), (src:Reference<MemoryAddress>), (dst:Reference<MemoryAddress>))


fn<Integer> copy <src: Reference<Integer>> to <dst: ReferenceMut<Integer>> -> None:
	let $tmp@1518: MemoryAddress = `address of <:Reference<Integer>>`((src:Reference<Integer>))
	let $tmp@1538: MemoryAddress = `address of <:Reference<Integer>>`((dst:ReferenceMut<Integer>))
	`copy <:Type<Integer>> from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1518:Reference<MemoryAddress>), (&$tmp@1538:Reference<MemoryAddress>))


@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("read_memory")
fn<Integer> <ty: Type<Integer>> at <address: Reference<MemoryAddress>> -> ReferenceMut<Integer>

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

@mangle_as("address_of")
fn<Integer> address of <ref: Reference<Integer>> -> MemoryAddress

fn<Integer> size of <ty: Type<Integer>> -> Integer:
	let $tmp@4399: Integer = `clone <:Reference<Integer>>`((ty:Type<Integer>).size)
	return ($tmp@4399:Integer)


fn<Integer> copy <:Type<Integer>> from <src: Reference<MemoryAddress>> to <dst: Reference<MemoryAddress>> -> None:
	`copy <:Reference<Integer>> bytes from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((&`size of <:Type<Integer>>`((Type<Integer>:Type<Integer>)):Reference<Integer>), (src:Reference<MemoryAddress>), (dst:Reference<MemoryAddress>))


fn<Integer> copy <src: Reference<Integer>> to <dst: ReferenceMut<Integer>> -> None:
	let $tmp@1518: MemoryAddress = `address of <:Reference<Integer>>`((src:Reference<Integer>))
	let $tmp@1538: MemoryAddress = `address of <:Reference<Integer>>`((dst:ReferenceMut<Integer>))
	`copy <:Type<Integer>> from <:Reference<MemoryAddress>> to <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1518:Reference<MemoryAddress>), (&$tmp@1538:Reference<MemoryAddress>))


fn<Integer> push <x: Integer> to <array: ReferenceMut<Array<Integer>>> -> None:
	let bytes: Integer = `size of <:Type<Integer>>`((Type<Integer>:Type<Integer>))
	if `<:Integer> == <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), `clone <:Reference<Integer>>`((*array:Array<Integer>).capacity)):
		let new_capacity: Integer = `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).capacity), 2)
		let new_data: MemoryAddress = `allocate <:Integer> <:Type<Integer>>`(`clone <:Reference<Integer>>`((new_capacity:Integer)), (Type<Integer>:Type<Integer>))
		let mut i: Integer = 0
		while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((*array:Array<Integer>).size)):
			let $tmp@916: MemoryAddress = `<:MemoryAddress> + <:Integer>`((new_data:MemoryAddress), `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((bytes:Integer))))
			let value: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@916:Reference<MemoryAddress>))
			`copy <:Reference<Integer>> to <:ReferenceMut<Integer>>`(`<:Reference<Array<Integer>>> [ <:Integer> ]`((array:ReferenceMut<Array<Integer>>), `clone <:Reference<Integer>>`((i:Integer))), (value:ReferenceMut<Integer>))
			`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)

		`free <:Reference<MemoryAddress>>`((&(*array:Array<Integer>).data:ReferenceMut<MemoryAddress>))
		(*array:Array<Integer>).data = (new_data:MemoryAddress)
		`destroy <:ReferenceMut<Integer>>`((*array:Array<Integer>).capacity)
		(*array:Array<Integer>).capacity = `clone <:Reference<Integer>>`((new_capacity:Integer))
		`destroy <:ReferenceMut<Integer>>`((new_capacity:Integer))
		`destroy <:ReferenceMut<Integer>>`((i:Integer))

	let $tmp@1068: MemoryAddress = `<:MemoryAddress> + <:Integer>`((*array:Array<Integer>).data, `<:Integer> * <:Integer>`(`clone <:Reference<Integer>>`((*array:Array<Integer>).size), `clone <:Reference<Integer>>`((bytes:Integer))))
	let value: ReferenceMut<Integer> = `<:Type<Integer>> at <:Reference<MemoryAddress>>`((Type<Integer>:Type<Integer>), (&$tmp@1068:Reference<MemoryAddress>))
	`copy <:Reference<Integer>> to <:ReferenceMut<Integer>>`((&x:Reference<Integer>), (value:ReferenceMut<Integer>))
	`<:ReferenceMut<Integer>> += <:Integer>`((&(*array:Array<Integer>).size:ReferenceMut<Integer>), 1)
	`destroy <:ReferenceMut<Integer>>`((bytes:Integer))


@mangle_as("integer_plus_integer")
fn <$arg0: Integer> + <$arg1: Integer> -> Integer

fn <self: ReferenceMut<Integer>> += <other: Integer> -> None:
	(self:ReferenceMut<Integer>) = `<:Integer> + <:Integer>`((*self:Integer), (other:Integer))


fn<Integer> String from <array: Array<Integer>> -> String:
	let mut str: String = "["
	if `<:Reference<Array<Integer>>> is not empty`((&array:Reference<Array<Integer>>)):
		`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), 0):Integer)))
		let mut i: Integer = 1
		while `<:Integer> < <:Integer>`(`clone <:Reference<Integer>>`((i:Integer)), `clone <:Reference<Integer>>`((array:Array<Integer>).size)):
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), ", ")
			`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), `String from <:Integer>`((*`<:Reference<Array<Integer>>> [ <:Integer> ]`((&array:Reference<Array<Integer>>), `clone <:Reference<Integer>>`((i:Integer))):Integer)))
			`<:ReferenceMut<Integer>> += <:Integer>`((&i:ReferenceMut<Integer>), 1)

		`destroy <:ReferenceMut<Integer>>`((i:Integer))

	`<:ReferenceMut<String>> += <:String>`((&str:ReferenceMut<String>), "]")
	let $tmp@1497: String = `clone <:Reference<String>>`((str:String))
	`destroy <:ReferenceMut<String>>`((str:String))
	return ($tmp@1497:String)


fn println <x: Array<Integer>> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Array<Integer>>`((x:Array<Integer>)))
	return ($tmp@176:None)
