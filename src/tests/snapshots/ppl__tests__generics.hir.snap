---
source: src/tests/mod.rs
expression: hir
---
type Point<T>:
	x: T
	y: T


fn<T> x of <p: Point<T>> -> T:
	let $tmp@53: T = (p:Point<T>).x
	return ($tmp@53:T)

let x: Integer = `x of <:Point<Integer>>`(Point<Integer> { x: 0, y: 0 })
`println <:Bool>`(`<:Integer> == <:Integer>`(`clone <:Reference<Integer>>`((x:Integer)), 0))

fn<T> id <x: T> -> T:
	let $tmp@127: T = (x:T)
	return ($tmp@127:T)

`println <:Bool>`(`<:Integer> == <:Integer>`(`id <:Integer>`(1), 1))
`println <:String>`(`id <:String>`("hello"))
`id <:Point<Integer>>`(Point<Integer> { x: 0, y: 0 })
`destroy <:ReferenceMut<Integer>>`((x:Integer))

==MONOMORPHIZED==


fn<Integer> x of <p: Point<Integer>> -> Integer:
	return (p:Point<Integer>).x


fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



fn<Integer> id <x: Integer> -> Integer:
	return (x:Integer)


fn String from <x: Bool> -> String:
	if (x:Bool):
		let $tmp@1245: String = "true"
		return ($tmp@1245:String)

	let $tmp@1260: String = "false"
	return ($tmp@1260:String)


fn println <x: Bool> -> None:
	let $tmp@176: None = `println <:String>`(`String from <:Bool>`((x:Bool)))
	return ($tmp@176:None)



fn<String> id <x: String> -> String:
	return (x:String)


fn<Point<Integer>> id <x: Point<Integer>> -> Point<Integer>:
	return (x:Point<Integer>)
