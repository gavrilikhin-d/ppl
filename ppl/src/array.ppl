use core.*

use math.*
use memory.*
use printable.*

/// Array of values
type Array<T>:
	size: Integer
	capacity: Integer
	data: MemoryAddress

/// Create an empty array
fn<T> <:Type<T>>[] -> Array<T>:
	let capacity = 8
	let data = allocate capacity T
	return Array<T> { size: 0, capacity, data }

// TODO: errors, if out of borders
/// Get i-th element of an array
fn<T> <array: &Array<T>> [ <i: Integer> ] -> &T:
	let address = array.data + i * (size of T)
	return T at address

// TODO: errors, if out of borders
/// Get i-th element of an array
fn<T> <array: &mut Array<T>> [ <i: Integer> ] -> &mut T:
	let address = array.data + i * (size of T)
	return T at address

fn<T> push <x: T> to <array: &mut Array<T>>:
	let bytes = size of T
	if array.size == array.capacity:
		let new_capacity = array.capacity * 2
		let new_data = allocate new_capacity T
		let mut i = 0
		while i < array.size:
			let value = T at (new_data + i * bytes)
			copy array[i] to value
			i += 1
		free array.data
		array.data = new_data
		array.capacity = new_capacity

	let value = T at (array.data + array.size * bytes)
	copy x to value
	array.size += 1

fn<T> <array: &Array<T>> is empty => array.size == 0
fn<T> <array: &Array<T>> is not empty => array.size > 0

fn<U: Printable> String from <array: Array<U>> -> String:
	let mut str = "["
	if array is not empty:
		str += (String from array[0])
		let mut i = 1
		while i < array.size:
			str += ", "
			str += (String from array[i])
			i += 1
	str += "]"
	return str

type Iterator<T>:
	array: &Array<T>
	index: Integer

fn<T> clone <it: &Iterator<T>> -> Iterator<T>:
	return Iterator<T> { array: it.array, index: it.index }

fn<T> iterator for <array: &Array<T>> -> Iterator<T>:
	return Iterator<T> { array, index: 0 }

fn<T> <it: &Iterator<T>> exists => it.index < it.array.size

fn<T> advance <it: &mut Iterator<T>>:
	it.index += 1

fn<T> value from <it: &Iterator<T>> -> &T:
	return it.array[it.index]